--[[
	The reconciler uses the virtual DOM generated by components to create a real
	tree of Roblox instances.

	The reonciler has three basic modes of operation:
	* reification (public as 'reify')
	* reconciliation (private)
	* teardown (public)

	Reification is the process of creating new nodes in the tree. This is first
	triggered when the user calls `Roact.reify` on a root element. This is where
	the structure of the concrete tree is built, later used and modified by the
	reconciliation step.

	Reconciliation accepts an existing concrete instance tree (created by reify)
	along with a new element that describes the desired new state.
	The reconciler will do the minimum amount of work required to update the
	instances to match the new element, sometimes invoking the reifier to create
	new branches.

	Teardown is the destructor for the tree. It will crawl through the tree,
	destroying nodes in the correct order and invoking lifecycle methods.
]]

local Core = require(script.Parent.Core)
local getDefaultPropertyValue = require(script.Parent.getDefaultPropertyValue)
local SingleEventManager = require(script.Parent.SingleEventManager)

local Reconciler = {}

Reconciler._singleEventManager = SingleEventManager.new()


--[[
	Destroy the given Roact instance, all of its descendants, and associated
	Roblox instances owned by the components.
]]
function Reconciler.teardown(instance)
	local element = instance._element

	if Core.isPrimitiveElement(element) then
		-- We're destroying a Roblox Instance-based object

		-- Kill refs before we make changes, since any mutations past this point
		-- aren't relevant to components.
		if element.props[Core.Ref] then
			element.props[Core.Ref](nil)
		end

		for _, child in pairs(instance._reifiedChildren) do
			Reconciler.teardown(child)
		end

		-- Necessary to make sure SingleEventManager doesn't leak references
		Reconciler._singleEventManager:disconnectAll(instance._rbx)

		instance._rbx:Destroy()
	elseif Core.isFunctionalElement(element) or Core.isStatefulElement(element) then
		-- Destroying a functional or stateful wrapper

		-- These components can return nil from render()
		if instance._reified then
			Reconciler.teardown(instance._reified)
		end

		if instance.willUnmount then
			instance:willUnmount()
		end
	else
		error(("Cannot teardown invalid Roact instance %q"):format(tostring(element)))
	end
end

--[[
	Public interface to reifier. Hides parameters used when recursing down the
	component tree.
]]
function Reconciler.reify(element, parent, key)
	return Reconciler._reifyInternal(element, parent, key)
end

--[[
	Instantiates components to represent the given element.

	Parameters:
		- `element`: The element to reify.
		- `parent`: The Roblox object to contain the contained instances
		- `key`: The Name to give the Roblox instance that gets created
		- `context`: Used to pass Roact context values down the tree

	The structure created by this method is important to the functionality of
	the _reconcile methods -- they depend on this structure being well-formed.
]]
function Reconciler._reifyInternal(element, parent, key, context)
	if Core.isPrimitiveElement(element) then
		-- Primitive elements are backed directly by Roblox Instances.

		-- Update Roblox properties
		local rbx = Instance.new(element.type)
		for key, value in pairs(element.props) do
			Reconciler._setRbxProp(rbx, key, value)
		end

		-- Create children!
		local reifiedChildren = {}

		if element.props[Core.Children] then
			for key, childElement in pairs(element.props[Core.Children]) do
				local childInstance = Reconciler._reifyInternal(childElement, rbx, key, context)

				reifiedChildren[key] = childInstance
			end
		end

		-- This name can be passed through multiple components.
		-- What's important is the final Roblox Instance receives the name
		-- It's solely for debugging purposes; Roact doesn't use it.
		if key then
			rbx.Name = key
		end

		rbx.Parent = parent

		-- Attach ref values, since the instance is initialized now.
		if element.props[Core.Ref] then
			element.props[Core.Ref](rbx)
		end

		return {
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
			_reifiedChildren = reifiedChildren,
			_rbx = rbx,
		}
	elseif Core.isFunctionalElement(element) then
		-- Functional elements contain 0 or 1 children.

		local instance = {
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
		}

		local vdom = element.type(element.props)
		if vdom then
			instance._reified = Reconciler._reifyInternal(vdom, parent, key, context)
		end

		return instance
	elseif Core.isStatefulElement(element) then
		-- Stateful elements have 0 or 1 children, and also have a backing
		-- instance that can keep state.

		local instance = element.type.new(element.props, context)

		-- These properties are set on the instance itself so that it can
		-- update itself.
		instance._key = key
		instance._parent = parent
		instance._element =  element

		local vdom = instance:render()
		if vdom then
			instance._reified = Reconciler._reifyInternal(vdom, parent, key, instance._context)
		end

		if instance.didMount then
			instance:didMount()
		end

		return instance
	end

	error(("Cannot reify invalid Roact element %q"):format(tostring(element)))
end

--[[
	Applies the state given by newElement to an existing Roact instance.

	_reconcile will return the instance that should be used. It can be different]]
function Reconciler._reconcile(instance, newElement)
	local oldElement = instance._element

	-- Instance was deleted!
	if not newElement then
		Reconciler.teardown(instance)

		return nil
	end

	-- If the element changes type, we assume its subtree will be substantially
	-- different. This lets us skip comparisons of a large swath of nodes.
	if oldElement.type ~= newElement.type then
		local parent = instance._parent
		local key = instance._key
		local context = instance._context

		Reconciler.teardown(instance)

		local newInstance = Reconciler._reifyInternal(newElement, parent, key, context)

		return newInstance
	end

	if Core.isPrimitiveElement(newElement) then
		-- Roblox Instance change

		local oldRef = oldElement[Core.Ref]
		local newRef = newElement[Core.Ref]
		local refChanged = (oldRef ~= newRef)

		-- Cancel the old ref before we make changes. Apply the new one after.
		if refChanged and oldRef then
			oldRef(nil)
		end

		-- Update properties and children of the Roblox object.
		Reconciler._reconcilePrimitiveProps(oldElement, newElement, instance._rbx)
		Reconciler._reconcilePrimitiveChildren(instance, newElement)

		instance._element = newElement

		-- Apply the new ref if there was a ref change.
		if refChanged and newRef then
			newRef(instance._rbx)
		end

		return instance
	elseif Core.isFunctionalElement(newElement) then
		instance._element = newElement

		local rendered = newElement.type(newElement.props)
		local newChild

		if instance._reified then
			-- Transition from tree to tree, even if 'rendered' is nil
			newChild = Reconciler._reconcile(instance._reified, rendered)
		elseif rendered then
			-- Transition from nil to new tree
			newChild = Reconciler._reifyInternal(rendered, instance._parent, instance._key, instance._context)
		end

		instance._reified = newChild

		return instance
	elseif Core.isStatefulElement(newElement) then
		instance._element = newElement

		-- Stateful elements can take care of themselves.
		instance:_update(newElement.props)

		return instance
	end

	error(("Cannot reconcile to match invalid Roact element %q"):format(tostring(newElement)))
end

--[[
	Reconciles the children of an existing Roact instance and the given element.
]]
function Reconciler._reconcilePrimitiveChildren(instance, newElement)
	local elementChildren = newElement.props[Core.Children]

	-- Reconcile existing children that were changed or removed
	for key, childInstance in pairs(instance._reifiedChildren) do
		local childElement = elementChildren and elementChildren[key]

		childInstance = Reconciler._reconcile(childInstance, childElement)

		instance._reifiedChildren[key] = childInstance
	end

	-- Create children that were just added!
	if elementChildren then
		for key, childElement in pairs(elementChildren) do
			-- Update if we didn't hit the child in the previous loop
			if not instance._reifiedChildren[key] then
				local childInstance = Reconciler._reifyInternal(childElement, instance._rbx, key, instance._context)
				instance._reifiedChildren[key] = childInstance
			end
		end
	end
end

--[[
	Reconciles the properties between two primitive Roact elements and applies
	the differences to the given Roblox object.
]]
function Reconciler._reconcilePrimitiveProps(fromElement, toElement, rbx)
	local seenProps = {}

	-- Set properties that were set with fromElement
	for key, oldValue in pairs(fromElement.props) do
		seenProps[key] = true

		local newValue = toElement.props[key]

		-- Assume any property that can be set to nil has a default value of nil
		if newValue == nil then
			local _, value = getDefaultPropertyValue(rbx.ClassName, key)

			-- We don't care if getDefaultPropertyValue fails, because
			-- _setRbxProp will catch the error below.
			newValue = value
		end

		-- Roblox does this check for normal values, but we have special
		-- properties like events that warrant this.
		if oldValue ~= newValue then
			Reconciler._setRbxProp(rbx, key, newValue)
		end
	end

	-- Set properties that are new in toElement
	for key, newValue in pairs(toElement.props) do
		if not seenProps[key] then
			seenProps[key] = true

			local oldValue = fromElement.props[key]

			if oldValue ~= newValue then
				Reconciler._setRbxProp(rbx, key, newValue)
			end
		end
	end
end

--[[
	Sets a property on a Roblox object, following Roact's rules for special
	case properties.

	This function can throw a couple different errors. In the future, calls to
	_setRbxProp should be wrapped in a pcall to give better errors to the user.

	For that to be useful, we'll need to attach a 'source' property on every
	element, created using debug.traceback(), that points to where the element
	was created.
]]
function Reconciler._setRbxProp(rbx, key, value)
	if type(key) == "string" then
		-- Regular property

		rbx[key] = value
	elseif type(key) == "table" then
		-- Special property with extra data attached.

		if key.type == "event" then
			Reconciler._singleEventManager:connect(rbx, key.name, value)
		else
			error(("Invalid special property type %q"):format(tostring(key.type)))
		end
	elseif type(key) ~= "userdata" then
		-- Userdata values are special markers, usually created by Symbol
		-- They have no data attached other than being unique keys

		error(("Properties of type %q are not supported"):format(type(key)))
	end
end

return Reconciler